{
    "version": "https://jsonfeed.org/version/1",
    "title": "玖忆 • All posts by \"hash\" tag",
    "description": "我本微末凡尘、可也心向天空",
    "home_page_url": "https://wait-you.github.io",
    "items": [
        {
            "id": "https://wait-you.github.io/2023/08/06/HashSet%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/",
            "url": "https://wait-you.github.io/2023/08/06/HashSet%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/",
            "title": "HashSet工作原理",
            "date_published": "2023-08-06T00:26:51.000Z",
            "content_html": "<h1 id=\"hashset-工作原理\"><a class=\"markdownIt-Anchor\" href=\"#hashset-工作原理\">#</a> HashSet 工作原理</h1>\n<blockquote>\n<p>HashSet 是 Java 中的一种集合类，它使用哈希表（Hash Table）来存储元素。在哈希表中，元素的存储位置是根据它们的哈希码（Hash Code）来确定的</p>\n</blockquote>\n<ul>\n<li>\n<p>hashCode () 方法</p>\n<ul>\n<li>每个 Java 对象都有一个 hashCode () 方法，它返回一个 32 位的整数值，表示对象的哈希码。哈希码是根据对象的内容计算出来的，通常情况下，如果两个对象相等（通过 equals () 方法比较），那么它们的 hashCode () 方法应该返回相同的值，但反之则不一定成立（这种情况称为哈希冲突）。</li>\n</ul>\n</li>\n<li>\n<p>哈希表</p>\n<ul>\n<li>HashSet 内部使用了一个哈希表来存储元素。哈希表实际上是一个数组，数组的每个位置被称为 “桶”（Bucket）。当你往 HashSet 中添加元素时，HashSet 会首先计算该元素的 hashCode () 方法的返回值。</li>\n</ul>\n</li>\n<li>\n<p>计算索引</p>\n<ul>\n<li>计算出的 hashCode 值经过一定的处理（通常是取绝对值，然后对数组长度取余），得到一个在哈希表中的索引，这个索引就表示了元素在数组中的存放位置。这个索引对应的桶就是元素的存储位置。</li>\n</ul>\n</li>\n<li>\n<p>解决哈希冲突</p>\n<ul>\n<li>由于不同的对象可能会有相同的哈希码，所以在计算得到的索引位置可能已经有其他元素存在。这种情况称为哈希冲突。为了解决冲突，HashSet 使用了一些方法，最常见的是在同一个索引位置使用链表或者更高效的红黑树来存储多个元素，从而确保同一个索引位置可以存储多个元素。</li>\n</ul>\n</li>\n<li>\n<p>查找元素</p>\n<ul>\n<li>当你需要查找一个元素时，HashSet 会首先根据要查找元素的 hashCode 计算出索引，然后在对应的桶中查找元素。如果在链表或者红黑树中找到了对应的元素，就说明元素存在于集合中。</li>\n</ul>\n</li>\n</ul>\n<p><strong>HashSet 利用对象的 hashCode () 方法来计算哈希码，然后通过哈希码计算出在哈希表中的索引位置，最终将元素存储在对应的桶中。这种设计使得在集合中查找、插入和删除元素的操作可以在平均情况下达到常数时间复杂度，从而实现高效的元素存储和查找</strong></p>\n<blockquote>\n<p>当涉及到底层实现细节时，查看源代码是理解的一个很好的方法。下面我将用一些简化的 Java 源代码来说明 HashSet 是如何通过哈希码确定对象的位置的</p>\n</blockquote>\n<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HashSet</span>&lt;E&gt; <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractSet</span>&lt;E&gt; <span class=\"keyword\">implements</span> <span class=\"title class_\">Set</span>&lt;E&gt;, Cloneable, Serializable &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 哈希表，用于存储元素</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 虚拟的常量，用于作为哈希表中的value，因为HashSet的实现依赖于HashMap</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Object</span> <span class=\"variable\">PRESENT</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 构造方法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">HashSet</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加元素</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">add</span><span class=\"params\">(E e)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> map.put(e, PRESENT) == <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 内部实现类，用于存储元素的哈希表</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HashMap</span>&lt;K,V&gt; <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractMap</span>&lt;K,V&gt; <span class=\"keyword\">implements</span> <span class=\"title class_\">Map</span>&lt;K,V&gt;, Cloneable, Serializable &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 哈希桶数组，用于存储元素</span></span><br><span class=\"line\">        <span class=\"keyword\">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 计算哈希码</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"title function_\">hash</span><span class=\"params\">(Object key)</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">h</span> <span class=\"operator\">=</span> key.hashCode();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (key == <span class=\"literal\">null</span>) ? <span class=\"number\">0</span> : h ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 计算元素在哈希表中的索引</span></span><br><span class=\"line\">        <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">indexFor</span><span class=\"params\">(<span class=\"type\">int</span> h, <span class=\"type\">int</span> length)</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> h &amp; (length-<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 添加元素到哈希表</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> V <span class=\"title function_\">put</span><span class=\"params\">(K key, V value)</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">hash</span> <span class=\"operator\">=</span> hash(key);</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> indexFor(hash, table.length);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Node&lt;K,V&gt; e = table[i]; e != <span class=\"literal\">null</span>; e = e.next) &#123;</span><br><span class=\"line\">                Object k;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class=\"line\">                    <span class=\"type\">V</span> <span class=\"variable\">oldValue</span> <span class=\"operator\">=</span> e.value;</span><br><span class=\"line\">                    e.value = value;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            addEntry(hash, key, value, i);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 哈希表中的一个节点</span></span><br><span class=\"line\">        <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Node</span>&lt;K,V&gt; <span class=\"keyword\">implements</span> <span class=\"title class_\">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">int</span> hash;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> K key;</span><br><span class=\"line\">            V value;</span><br><span class=\"line\">            Node&lt;K,V&gt; next;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// ...</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></div>\n<p>上述代码只是一个简化版的示例，实际的 HashSet 和 HashMap 实现要更加复杂。关键点是：</p>\n<ul>\n<li>\n<p>HashSet 内部实际上使用了一个 HashMap 来存储元素，HashMap 中使用了哈希桶数组来存储节点。</p>\n</li>\n<li>\n<p>当调用 add () 方法将元素添加到 HashSet 时，实际上是通过 HashMap 的 put () 方法将元素添加到哈希表中。</p>\n</li>\n<li>\n<p>在 put () 方法中，首先会计算元素的哈希码，然后使用哈希码计算出在哈希桶数组中的索引位置。</p>\n</li>\n<li>\n<p>如果该索引位置已经存在其他节点（可能是哈希冲突），则会遍历链表或红黑树（根据节点数量）查找合适的位置来插入元素。</p>\n</li>\n</ul>\n<p><strong>总之，HashSet 利用了 HashMap 的哈希表实现，通过计算哈希码并选择合适的索引位置来确定对象在集合中的位置。这种机制保证了高效的元素查找和存储。要深入理解更多细节，最好还是查看 Java 源代码的实现。</strong></p>\n<p>源码中的 hash () 方法可能是一个疑点，他的作用及原理如下:<br>\n 假设我们有一个哈希码 h，二进制表示为： <code>11001010101110011011100110100101</code></p>\n<p>现在，我们进行无符号右移操作 h &gt;&gt;&gt; 16，将低 16 位移到高位，得到： <code>00000000000000001100101010111001</code></p>\n<p>接下来，我们进行异或操作 h ^ (h&gt;&gt;&gt; 16)，对应的位进行异或操作：</p>\n<div class=\"highlight-container\" data-rel=\"Markdown\"><figure class=\"iseeu highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">11001010101110011011100110100101</span><br><span class=\"line\"><span class=\"section\">00000000000000001100101010111001</span></span><br><span class=\"line\"><span class=\"section\">--------------------------------</span></span><br><span class=\"line\">11001010101110010111001100011100</span><br></pre></td></tr></table></figure></div>\n<p>通过异或操作，我们将原始哈希码的高位和低位进行了混合。现在，如果我们将得到的结果再转化为十进制，得到： <code>3361659324</code> 。</p>\n<p>这个结果相比于原始哈希码  <code>2864585453</code> ，已经发生了很大变化。这种混合的效果在位级别上实际上是将原始哈希码的不同部分交织在一起，增加了分布的随机性。这样的随机性有助于减少哈希冲突的发生，从而提高了哈希表的性能。</p>\n<p><strong>总之，位运算 h ^ (h&gt;&gt;&gt; 16) 的作用是将原始哈希码的高位和低位进行混合，生成一个在位级别上更随机的结果，从而提高哈希码的分布性</strong>。</p>\n<blockquote>\n<p>面试题</p>\n</blockquote>\n<p><strong>为什么重写 equals（）方法，就一定要重写 hashCode（）方法？</strong></p>\n<p>在 Java 中，当重写了 equals () 方法，目标是要在逻辑上判断两个对象是否相等，即它们的内容是否相同。然而，在涉及散列集合（如 HashSet、HashMap 等）时，不仅需要考虑逻辑上的相等，还需要确保哈希码相等的对象被放置在哈希表中同一个位置。这样才能正确地执行插入、查找、删除等操作。</p>\n<p>如果只重写了 equals () 方法，但没有重写 hashCode () 方法，就有可能出现以下问题：</p>\n<ul>\n<li>\n<p>不一致的哈希码： 两个对象在 equals () 方法中被判断为相等，但由于它们的 hashCode () 方法返回不同的哈希码，它们在散列集合中被当作不同的键插入。这会导致你无法正确查找或删除这些对象。</p>\n</li>\n<li>\n<p>无法正确覆盖： 在散列集合中，如果你希望用新的对象覆盖旧的对象（基于 equals () 判断相等），你需要确保新对象的哈希码与旧对象的哈希码相同。否则，你的新对象将被错误地放置在哈希表的另一个位置。</p>\n</li>\n</ul>\n<p>所以，为了保证逻辑相等的对象在散列集合中能够被正确地处理，必须同时重写 equals () 和 hashCode () 方法。这样，可以确保相等的对象拥有相同的哈希码，从而保证它们被正确处理并存储在散列集合中。</p>\n<p><strong>总之，重写 hashCode () 方法主要是为了保证逻辑相等的对象在散列集合中能够正确处理。如果仅在一般的逻辑判断中使用 equals () 方法，那么重写 hashCode () 并不是必需的。</strong></p>\n",
            "tags": [
                "面试题",
                "Hash"
            ]
        }
    ]
}
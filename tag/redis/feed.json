{
    "version": "https://jsonfeed.org/version/1",
    "title": "玖忆 • All posts by \"redis\" tag",
    "description": "我本微末凡尘、可也心向天空",
    "home_page_url": "https://wait-you.github.io",
    "items": [
        {
            "id": "https://wait-you.github.io/2023/09/02/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/",
            "url": "https://wait-you.github.io/2023/09/02/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/",
            "title": "布隆过滤器",
            "date_published": "2023-09-01T18:14:35.000Z",
            "content_html": "<h1 id=\"布隆过滤器\"><a class=\"markdownIt-Anchor\" href=\"#布隆过滤器\">#</a> 布隆过滤器</h1>\n<h2 id=\"概念\"><a class=\"markdownIt-Anchor\" href=\"#概念\">#</a> 概念</h2>\n<p>一个很长的二进制向量，一个二进制数组，由 0 和 1 组成，主要作用是判断一个数据存不存在这个于这个数组中，如果不存在就是 0，如果存在的话就是 1，使用 0 和 1 的二进制存储来表示存在的关系。</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"http://tuchuang.wenhe9.cn/img/202309011047204.png\"\n                      alt=\"image-20230901104721073\"\n                ></p>\n<h2 id=\"原理\"><a class=\"markdownIt-Anchor\" href=\"#原理\">#</a> 原理</h2>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"http://tuchuang.wenhe9.cn/img/202309011049425.png\"\n                      alt=\"image-20230901104936302\"\n                ></p>\n<h3 id=\"存入过程\"><a class=\"markdownIt-Anchor\" href=\"#存入过程\">#</a> 存入过程</h3>\n<p>经过 hash 算法对数据进行计算，然后对数组长度进行取模，进而得到他在数组中的位置，然后将该位置的值设置成 1</p>\n<h3 id=\"查询过程\"><a class=\"markdownIt-Anchor\" href=\"#查询过程\">#</a> 查询过程</h3>\n<p>经过多个 hash 算法计算取模后，所有位置的值都是 1 就是表示这个数据存在，否则就表示这个数据不存在</p>\n<ul>\n<li>多个 hash 函数</li>\n<li>二进制数据必须都是 1</li>\n</ul>\n<h3 id=\"删除数据\"><a class=\"markdownIt-Anchor\" href=\"#删除数据\">#</a> 删除数据</h3>\n<p>很难实现删除</p>\n<p>可能会出现多个数据计算出的 hash 取模后的下标位置是同一个位置，即这个位置可能存在多个数据，那么当删除其中一个数据时，可能会导致另一个数据也会被误删。</p>\n<h2 id=\"优点-缺点\"><a class=\"markdownIt-Anchor\" href=\"#优点-缺点\">#</a> 优点、缺点</h2>\n<h3 id=\"优点\"><a class=\"markdownIt-Anchor\" href=\"#优点\">#</a> 优点</h3>\n<ul>\n<li>是由一串二进制数组组成，所以占用空间非常小</li>\n<li>插入和查询是很快的，因为他是计算数据的 hash 值，然后再由 hash 值映射到数组的下标，基于数组的特性，他的查询和插入时很快的，所以他的时间复杂度是 o (k)，k 表示 hash 函数的个数</li>\n<li>保密性好，存储的都是二进制数据，本身也不存储原始数据，无法得知 0、1 的意义是什么</li>\n</ul>\n<h3 id=\"缺点\"><a class=\"markdownIt-Anchor\" href=\"#缺点\">#</a> 缺点</h3>\n<ul>\n<li>很难实现删除操作</li>\n<li>存在误判这个数据本身不存在数组中，但是经过一系列计算后，判断这个数据存在于数组中，hash 冲突，解决办法是减小误判率，但是不能过小，因为减小误判率是通过增加 hash 函数实现的，当增加 hash 函数时，除了会增加计算时间外，因为会出现多个 hash 结果，他映射到数组中的位置也会增多，空间占用也会增加。为 1 不一定存在，但是为 0 一定不存在。</li>\n</ul>\n<h2 id=\"解决缓存穿透\"><a class=\"markdownIt-Anchor\" href=\"#解决缓存穿透\">#</a> 解决缓存穿透</h2>\n<p>当大量数据访问一个不存在于缓存中的数据，导致请求直接访问后端存储（如数据库），并且由于数据不存在，这个请求在缓存和后端存储中都没有命中，从而导致大量的请求流向后端存储，增加了系统的负载和响应时间。</p>\n<p>主要原因是恶意用户或者系统错误导致大量查询缓存中不存在的数据，这样的请求会绕过缓存，直接访问后端存储，导致后端存储的压力增大。</p>\n<p>为了应对缓存穿透问题，可以考虑以下方法：</p>\n<ol>\n<li><strong>缓存空值：</strong> 即使数据不存在，也在缓存中存储一个特殊值，表示这个数据不存在。这样，在下一次请求同样的数据时，就可以从缓存中快速判断数据不存在，而不会再次访问后端存储。</li>\n<li><strong>使用布隆过滤器：</strong> 布隆过滤器可以用来快速判断某个数据是否存在于缓存中。如果布隆过滤器判断数据不存在，就可以避免绕过缓存直接访问后端存储。</li>\n<li><strong>热点数据预加载：</strong> 针对系统中的热点数据，可以在系统启动时提前加载到缓存中，避免由于查询热点数据时导致缓存穿透。</li>\n<li><strong>限制请求频率：</strong> 可以在缓存层面限制同一个请求的频率，避免大量的恶意请求绕过缓存直接访问后端存储。</li>\n<li><strong>使用缓存云平台：</strong> 一些缓存云平台（如 AWS Elasticache、Redis Labs 等）提供了针对缓存穿透的解决方案，可以自动处理缓存穿透问题。</li>\n</ol>\n<h2 id=\"代码示例\"><a class=\"markdownIt-Anchor\" href=\"#代码示例\">#</a> 代码示例</h2>\n<p>这里的示例以我的用户是否浏览过记忆为例：</p>\n<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@RequiredArgsConstructor</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserViewedMemoryBloomFilterUtil</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">BLOOM_FILTER_KEY_PREFIX</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;memory_bloom_filter:&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">double</span> <span class=\"variable\">EXPECTED_INSERTIONS</span> <span class=\"operator\">=</span> <span class=\"number\">100000</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">double</span> <span class=\"variable\">FPP</span> <span class=\"operator\">=</span> <span class=\"number\">0.03</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 判断某个用户是否浏览过某个记忆</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> userId   用户ID</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> memoryId 记忆ID</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> true表示用户已经浏览过，false表示用户未浏览过</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">hasViewedMemory</span><span class=\"params\">(String userId, String memoryId)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">bloomFilterKey</span> <span class=\"operator\">=</span> BLOOM_FILTER_KEY_PREFIX + userId;</span><br><span class=\"line\">        <span class=\"type\">long</span>[] offsets = bloomFilterOffsets(memoryId);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">byte</span>[] bloomFilterBytes = (<span class=\"type\">byte</span>[]) redisTemplate.opsForValue().get(bloomFilterKey);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (bloomFilterBytes == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 布隆过滤器为空，则用户一定未浏览过该记忆</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 判断该记忆是否在布隆过滤器中</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">long</span> offset : offsets) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!getBit(bloomFilterBytes, offset)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 将某个记忆标记为已浏览过</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> userId   用户ID</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> memoryId 记忆ID</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">markMemoryAsViewed</span><span class=\"params\">(String userId, String memoryId)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">bloomFilterKey</span> <span class=\"operator\">=</span> BLOOM_FILTER_KEY_PREFIX + userId;</span><br><span class=\"line\">        <span class=\"type\">long</span>[] offsets = bloomFilterOffsets(memoryId);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">byte</span>[] bloomFilterBytes = (<span class=\"type\">byte</span>[]) redisTemplate.opsForValue().get(bloomFilterKey);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (bloomFilterBytes == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            bloomFilterBytes = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[getBloomFilterSize(EXPECTED_INSERTIONS, FPP)];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 将该记忆对应的位设置为1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">long</span> offset : offsets) &#123;</span><br><span class=\"line\">            setBit(bloomFilterBytes, offset);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        redisTemplate.opsForValue().set(bloomFilterKey, bloomFilterBytes);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取某个记忆在布隆过滤器中对应的位</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> memoryId 记忆ID</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 位的数组</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">long</span>[] bloomFilterOffsets(String memoryId) &#123;</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">hash1</span> <span class=\"operator\">=</span> MurmurHash.hash64(memoryId.getBytes(StandardCharsets.UTF_8), <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">hash2</span> <span class=\"operator\">=</span> MurmurHash.hash64(memoryId.getBytes(StandardCharsets.UTF_8), (<span class=\"type\">int</span>) hash1, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"type\">long</span>[] offsets = <span class=\"keyword\">new</span> <span class=\"title class_\">long</span>[<span class=\"number\">2</span>];</span><br><span class=\"line\">        offsets[<span class=\"number\">0</span>] = Math.abs(hash1 % getBloomFilterSize(EXPECTED_INSERTIONS, FPP));</span><br><span class=\"line\">        offsets[<span class=\"number\">1</span>] = Math.abs(hash2 % getBloomFilterSize(EXPECTED_INSERTIONS, FPP));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> offsets;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取布隆过滤器的大小</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> expectedInsertions 预期插入数量</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> fpp                期望的误判率</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 布隆过滤器的大小</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"title function_\">getBloomFilterSize</span><span class=\"params\">(<span class=\"type\">double</span> expectedInsertions, <span class=\"type\">double</span> fpp)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 根据预期插入数量和误判率计算布隆过滤器的大小</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">size</span> <span class=\"operator\">=</span> (<span class=\"type\">int</span>) Math.ceil((-expectedInsertions * Math.log(fpp)) / (Math.log(<span class=\"number\">2</span>) * Math.log(<span class=\"number\">2</span>)));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> size;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取指定位置的位的值</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> bytes  字节数组</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> offset 位的位置</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 位的值，true 表示 1，false 表示 0</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"title function_\">getBit</span><span class=\"params\">(<span class=\"type\">byte</span>[] bytes, <span class=\"type\">long</span> offset)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 因为一个 byte 等于 8 个 bit</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">index</span> <span class=\"operator\">=</span> (<span class=\"type\">int</span>) (offset / <span class=\"number\">8</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 得到在一个字节中的下标位置</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">bitPos</span> <span class=\"operator\">=</span> (<span class=\"type\">int</span>) (offset % <span class=\"number\">8</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 位运算，偏移 bitPos 下标位置的向量</span></span><br><span class=\"line\">        <span class=\"type\">byte</span> <span class=\"variable\">mask</span> <span class=\"operator\">=</span> (<span class=\"type\">byte</span>) (<span class=\"number\">1</span> &lt;&lt; bitPos);</span><br><span class=\"line\">        <span class=\"comment\">// 和数组中的对应位置的字节中的8位bit进行与运算，当该位置存在时即不等于0</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> (bytes[index] &amp; mask) != <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 将指定位置的位设置为 1</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> bytes  字节数组</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> offset 位的位置</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setBit</span><span class=\"params\">(<span class=\"type\">byte</span>[] bytes, <span class=\"type\">long</span> offset)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">index</span> <span class=\"operator\">=</span> (<span class=\"type\">int</span>) (offset / <span class=\"number\">8</span>);</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">bitPos</span> <span class=\"operator\">=</span> (<span class=\"type\">int</span>) (offset % <span class=\"number\">8</span>);</span><br><span class=\"line\">        <span class=\"type\">byte</span> <span class=\"variable\">mask</span> <span class=\"operator\">=</span> (<span class=\"type\">byte</span>) (<span class=\"number\">1</span> &lt;&lt; bitPos);</span><br><span class=\"line\">        <span class=\"comment\">// 或运算，只有该位置不存在时才将该位置设置成1</span></span><br><span class=\"line\">        bytes[index] |= mask;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></div>\n",
            "tags": [
                "面试题",
                "redis"
            ]
        }
    ]
}
{
    "version": "https://jsonfeed.org/version/1",
    "title": "玖忆 • All posts by \"service mesh\" tag",
    "description": "我本微末凡尘、可也心向天空",
    "home_page_url": "https://wait-you.github.io",
    "items": [
        {
            "id": "https://wait-you.github.io/2023/06/06/Service-Mesh/",
            "url": "https://wait-you.github.io/2023/06/06/Service-Mesh/",
            "title": "Service Mesh",
            "date_published": "2023-06-06T01:04:38.000Z",
            "content_html": "<h2 id=\"service-mesh\"><a class=\"markdownIt-Anchor\" href=\"#service-mesh\">#</a> Service Mesh</h2>\n<p><strong>下一代微服务技术</strong></p>\n<h3 id=\"服务开发模式和service-mesh的演化过程\"><a class=\"markdownIt-Anchor\" href=\"#服务开发模式和service-mesh的演化过程\">#</a> 服务开发模式和 Service Mesh 的演化过程</h3>\n<p>时代 0：开发人员想象中，不同服务间通信的方式，抽象表示如下：</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"http://tuchuang.wenhe9.cn/img/202212052320689.png\"\n                      alt=\"image-20221205232021596\"\n                ></p>\n<p>时代 1：原始通信时代</p>\n<p>然而现实远比想象的复杂，在实际情况中，通信需要底层能够传输字节码和电子信号的物理层来完成，在 TCP 协议出现之前，服务需要自己处理网络通信所面临的丢包、乱序、重试等一系列流控问题，因此服务实现中，除了业务逻辑外，还夹杂着对网络传输问题的处理逻辑。</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"http://tuchuang.wenhe9.cn/img/202212052320123.png\"\n                      alt=\"image-20221205232053063\"\n                ></p>\n<p>时代 2：TCP 时代</p>\n<p>为了避免每个服务都需要自己实现一套相似的网络传输处理逻辑，TCP 协议出现了，它解决了网络传输中通用的流量控制问题，将技术栈下移，从服务的实现中抽离出来，成为操作系统网络层的一部分。<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"http://tuchuang.wenhe9.cn/img/202212052321899.png\"\n                      alt=\"image-20221205232111840\"\n                ></p>\n<p>时代 3：第一代微服务</p>\n<p>在 TCP 出现之后，机器之间的网络通信不再是一个难题，以 GFS/BigTable/MapReduce 为代表的分布式系统得以蓬勃发展。这时，分布式系统特有的通信语义又出现了，如熔断策略、负载均衡、服务发现、认证和授权、quota 限制、trace 和监控等等，于是服务根据业务需求来实现一部分所需的通信语义。</p>\n<p>时代 4：第二代微服务</p>\n<p>为了避免每个服务都需要自己实现一套分布式系统通信的语义功能，随着技术的发展，一些面向微服务架构的开发框架出现了，如 Twitter 的 Finagle、Facebook 的 Proxygen 以及 Spring Cloud 等等，这些框架实现了分布式系统通信需要的各种通用语义功能：如负载均衡和服务发现等，因此一定程度上屏蔽了这些通信细节，使得开发人员使用较少的框架代码就能开发出健壮的分布式系统。<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"http://tuchuang.wenhe9.cn/img/202212052322328.png\"\n                      alt=\"image-20221205232220241\"\n                ></p>\n<p>时代 5：第一代 Service Mesh</p>\n<p>第二代微服务模式看似完美，但开发人员很快又发现，它也存在一些本质问题：</p>\n<ul>\n<li>其一，虽然框架本身屏蔽了分布式系统通信的一些通用功能实现细节，但开发者却要花更多精力去掌握和管理复杂的框架本身，在实际应用中，去<strong>追踪和解决框架出现的问题</strong>也绝非易事；</li>\n<li>其二，<strong>开发框架通常只支持一种或几种特定的语言</strong>，回过头来看文章最开始对<strong>微服务的定义，一个重要的特性就是语言无关</strong>，但那些没有框架支持的语言编写的服务，很难融入面向微服务的架构体系，想因地制宜的用多种语言实现架构体系中的不同模块也很难做到；</li>\n<li>其三，框架以 lib 库的形式和服务联编，<strong>复杂项目依赖时的库版本兼容问题</strong>非常棘手，同时，框架库的升级也无法对服务透明，服务会因为和业务无关的 lib 库升级而被迫升级；</li>\n</ul>\n<p>因此以 Linkerd，Envoy，NginxMesh 为代表的代理模式（边车模式）应运而生，这就是第一代 Service Mesh，它将分布式服务的通信抽象为单独一层，在这一层中实现负载均衡、服务发现、认证授权、监控追踪、流量控制等分布式系统所需要的功能，作为一个和服务对等的代理服务，和服务部署在一起，接管服务的流量，通过代理之间的通信间接完成服务之间的通信请求，这样上边所说的三个问题也迎刃而解。</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"http://tuchuang.wenhe9.cn/img/202212052324688.png\"\n                      alt=\"image-20221205232402606\"\n                ></p>\n<p>如果我们从一个全局视角来看，就会得到如下部署图：</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"http://tuchuang.wenhe9.cn/img/202212052324365.png\"\n                      alt=\"image-20221205232415268\"\n                ></p>\n<p>如果我们暂时略去服务，只看 Service Mesh 的单机组件组成的网络：</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"http://tuchuang.wenhe9.cn/img/202212052324621.png\"\n                      alt=\"image-20221205232426529\"\n                ></p>\n<p>所谓 Service Mesh，也就是服务网格。它看起来确实就像是一个由若干服务代理所组成的错综复杂的网格。</p>\n<p>时代 6：第二代 Service Mesh</p>\n<p>第一代 Service Mesh 由一系列独立运行的单机代理服务构成，为了提供统一的上层运维入口，演化出了集中式的控制面板，所有的单机代理组件通过和控制面板交互进行网络拓扑策略的更新和单机数据的汇报。这就是以 Istio 为代表的第二代 Service Mesh。</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"http://tuchuang.wenhe9.cn/img/202212052325344.png\"\n                      alt=\"image-20221205232533256\"\n                ></p>\n<p>只看单机代理组件 (数据面板) 和控制面板的 Service Mesh 全局部署视图如下：<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"http://tuchuang.wenhe9.cn/img/202212052325162.png\"\n                      alt=\"image-20221205232545075\"\n                ></p>\n<p>Service Mesh 的定义：</p>\n<blockquote>\n<p>服务网格是一个<em><strong>基础设施层</strong>，用于处理服务间通信。云原生应用有着复杂的服务拓扑，服务网格保证</em><em>请求在这些拓扑中可靠地穿梭</em> *。在实际应用当中，服务网格通常是由一系列轻量级的<strong>网络代理</strong>组成的，它们与应用程序部署在一起，但<strong>对应用程序透明</strong>。</p>\n</blockquote>\n<p>这个定义中，有四个关键词：</p>\n<p><em><strong>基础设施层</strong></em> +<em><strong> 请求在这些拓扑中可靠穿梭</strong></em>：这两个词加起来描述了 Service Mesh 的定位和功能，是不是似曾相识？没错，你一定想到了 TCP；</p>\n<p><em><strong>网络代理</strong></em>：这描述了 Service Mesh 的实现形态；</p>\n<p><em><strong>对应用透明</strong></em>：这描述了 Service Mesh 的关键特点，正是由于这个特点，Service Mesh 能够解决以 Spring Cloud 为代表的第二代微服务框架所面临的三个本质问题；</p>\n<p>Service Mesh 优点：</p>\n<ul>\n<li>屏蔽分布式系统通信的复杂性 (负载均衡、服务发现、认证授权、监控追踪、流量控制等等)，服务只用关注业务逻辑；</li>\n<li>真正的语言无关，服务可以用任何语言编写，只需和 Service Mesh 通信即可；</li>\n<li>对应用透明，Service Mesh 组件可以单独升级；</li>\n</ul>\n<p>Service Mesh 的挑战：</p>\n<ul>\n<li>Service Mesh 组件以代理模式计算并转发请求，一定程度上会降低通信系统性能，并增加系统资源开销；</li>\n<li>Service Mesh 组件接管了网络流量，因此服务的整体稳定性依赖于 Service Mesh，同时额外引入的大量 Service Mesh 服务实例的运维和管理也是一个挑战；</li>\n</ul>\n<h2 id=\"东西流量和南北流量\"><a class=\"markdownIt-Anchor\" href=\"#东西流量和南北流量\">#</a> 东西流量和南北流量</h2>\n<p>南北流量（NORTH-SOUTH traffic）和东西流量（EAST-WEST traffic）是数据中心环境中的网络流量模式。</p>\n<p>假设我们尝试通过浏览器访问某些 Web 应用。Web 应用部署在位于某个数据中心的应用服务器中。在多层体系结构中，典型的数据中心不仅包含应用服务器，还包含其他服务器，如负载均衡器、数据库等，以及路由器和交换机等网络组件。假设应用服务器是负载均衡器的前端。</p>\n<p>当我们访问 web 应用时，会发生以下类型的网络流量：</p>\n<ul>\n<li>客户端（位于数据中心一侧的浏览器）与负载均衡器（位于数据中心）之间的网络流量</li>\n<li>负载均衡器、应用服务器、数据库等之间的网络流量，它们都位于数据中心。</li>\n</ul>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"http://tuchuang.wenhe9.cn/img/202212052334033.png\"\n                      alt=\"image-20221205233404891\"\n                ></p>\n<h3 id=\"南北流量\"><a class=\"markdownIt-Anchor\" href=\"#南北流量\">#</a> 南北流量</h3>\n<p>在这个例子中，前者即即客户端和服务器之间的流量被称为南北流量。简而言之，南北流量是 server-client 流量。</p>\n<h3 id=\"东西流量\"><a class=\"markdownIt-Anchor\" href=\"#东西流量\">#</a> 东西流量</h3>\n<p>第二种流量即不同服务器之间的流量与数据中心或不同数据中心之间的网络流被称为东西流量。简而言之，东西流量是 server-server 流量。</p>\n",
            "tags": [
                "Service Mesh"
            ]
        }
    ]
}
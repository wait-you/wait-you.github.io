{
    "version": "https://jsonfeed.org/version/1",
    "title": "玖忆 • All posts by \"面试题\" tag",
    "description": "我本微末凡尘、可也心向天空",
    "home_page_url": "https://wait-you.github.io",
    "items": [
        {
            "id": "https://wait-you.github.io/2023/09/02/MVCC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/",
            "url": "https://wait-you.github.io/2023/09/02/MVCC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/",
            "title": "MVCC底层原理",
            "date_published": "2023-09-01T23:29:21.000Z",
            "content_html": "<h1 id=\"mvcc底层原理\"><a class=\"markdownIt-Anchor\" href=\"#mvcc底层原理\">#</a> MVCC 底层原理</h1>\n<h2 id=\"概念\"><a class=\"markdownIt-Anchor\" href=\"#概念\">#</a> 概念</h2>\n<p>MVCC 是多版本并发控制</p>\n<p>它是由两部分组成的</p>\n<ul>\n<li>undo log 版本链\n<ul>\n<li>当事务中有操作对数据进行修改的时候，就会将原数据存放到 undo log 中，用于回滚或查询</li>\n<li>其中需要注意的是数据库中的数据表的每一条数据都有两个隐藏的字段\n<ul>\n<li>trx_id 更新该数据的事务 id</li>\n<li>roll_pointer 更新该数据的上一条原始数据的 id</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>read view 读视图\n<ul>\n<li>在查询数据时生成的数据</li>\n<li>由四部分组成\n<ul>\n<li>m_ids 当前活跃的事务 id，即未提交事务的 id 列表</li>\n<li>min_trx_id 未提交事务中最小的 id，即这些未提交事务操作的数据的最原始的数据行的操作事务 id</li>\n<li>max_trx_id 未提交事务中最大的事务 id+1，即下一个将要分配的事务 id</li>\n<li>creator_trx_id 创建该视图的事务 id</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"读提交-rc\"><a class=\"markdownIt-Anchor\" href=\"#读提交-rc\">#</a> 读提交 RC</h2>\n<ol>\n<li>如下图所示，当事务的隔离级别位读提交时，每次查询数据时都会产生一个 read view</li>\n<li>当因为每次查询都会产生新的 read view，当前一次查询数据时，使用最小事务 id 获取到原始数据，过了一段时间后，该事务再次进行查询时，可能会因为之前活跃的事务中已经有事务进行了提交，导致最小事务 id 发生了变化，获取到了新的原始数据，导致两次查询到的数据不一致，就会导致幻读，即不可重复读现象的发生。</li>\n<li>因为每次查询时都产生新的 read view，所以每次的活跃事务和最小事务等都会随着其他事务的提交而发生变化，就会导致在该事务的不同阶段，查询的结果也会不断发生变化。</li>\n</ol>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"http://tuchuang.wenhe9.cn/img/202309011536015.png\"\n                      alt=\"image-20230901153026329\"\n                ></p>\n<h2 id=\"可重复读-rr\"><a class=\"markdownIt-Anchor\" href=\"#可重复读-rr\">#</a> 可重复读 RR</h2>\n<p>与读提交不同的是，他是在事务开启的时候，就会去创建一个 read view  之后的每一次查询都是复用之前创建的 read view</p>\n<p>如此的话，每次查询时，使用的都是同一个事务 id，故而从 undo log 中查询到的原始数据也是同一个了</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"http://tuchuang.wenhe9.cn/img/202309011656486.png\"\n                      alt=\"image-20230901165602351\"\n                ></p>\n<p>但是，RR 并不能完全解决不可重复读的问题，原因如下：</p>\n<p>在 mysql 的读操作中，分为两种类型</p>\n<ul>\n<li>\n<p>快照读 select 语句在不加锁的情况下就是 快照读</p>\n<ul>\n<li>\n<pre><code class=\"language-mysql\">select * from xxx_table where ...\n<div class=\"highlight-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">- 当前读 加锁的 select ，或者对数据进行增删改都会进行 当前读</span><br><span class=\"line\"></span><br><span class=\"line\">  - ```mysql</span><br><span class=\"line\">    select * from xxx_table Lock In Share Mode;</span><br><span class=\"line\">    select * from xxx_table for update;</span><br><span class=\"line\">    insert into xxx_table...</span><br><span class=\"line\">    delete from xxx_table...</span><br><span class=\"line\">    update xxx_table...</span><br></pre></td></tr></table></figure></div>\n\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<p>当进行当前读的时候，会根据条件加 临键锁 (Next-Key Lock) ，当要操作的数据在临键锁的范围覆盖了其他事务的数据，那么将再次生成新的 read view 这时，可能会出现不可重复读的问题，如果要操作的数据不在临键锁的范围内，那么将复用一开始的 read view，则不会出现幻读。</p>\n<p>综上，<strong>在 RR 隔离级别下，快照读完全解决了幻读，当前读部分解决了幻读</strong></p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"http://tuchuang.wenhe9.cn/img/202309011714117.png\"\n                      alt=\"image-20230901171456013\"\n                ></p>\n",
            "tags": [
                "面试题",
                "mysql"
            ]
        },
        {
            "id": "https://wait-you.github.io/2023/09/02/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/",
            "url": "https://wait-you.github.io/2023/09/02/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/",
            "title": "布隆过滤器",
            "date_published": "2023-09-01T18:14:35.000Z",
            "content_html": "<h1 id=\"布隆过滤器\"><a class=\"markdownIt-Anchor\" href=\"#布隆过滤器\">#</a> 布隆过滤器</h1>\n<h2 id=\"概念\"><a class=\"markdownIt-Anchor\" href=\"#概念\">#</a> 概念</h2>\n<p>一个很长的二进制向量，一个二进制数组，由 0 和 1 组成，主要作用是判断一个数据存不存在这个于这个数组中，如果不存在就是 0，如果存在的话就是 1，使用 0 和 1 的二进制存储来表示存在的关系。</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"http://tuchuang.wenhe9.cn/img/202309011047204.png\"\n                      alt=\"image-20230901104721073\"\n                ></p>\n<h2 id=\"原理\"><a class=\"markdownIt-Anchor\" href=\"#原理\">#</a> 原理</h2>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"http://tuchuang.wenhe9.cn/img/202309011049425.png\"\n                      alt=\"image-20230901104936302\"\n                ></p>\n<h3 id=\"存入过程\"><a class=\"markdownIt-Anchor\" href=\"#存入过程\">#</a> 存入过程</h3>\n<p>经过 hash 算法对数据进行计算，然后对数组长度进行取模，进而得到他在数组中的位置，然后将该位置的值设置成 1</p>\n<h3 id=\"查询过程\"><a class=\"markdownIt-Anchor\" href=\"#查询过程\">#</a> 查询过程</h3>\n<p>经过多个 hash 算法计算取模后，所有位置的值都是 1 就是表示这个数据存在，否则就表示这个数据不存在</p>\n<ul>\n<li>多个 hash 函数</li>\n<li>二进制数据必须都是 1</li>\n</ul>\n<h3 id=\"删除数据\"><a class=\"markdownIt-Anchor\" href=\"#删除数据\">#</a> 删除数据</h3>\n<p>很难实现删除</p>\n<p>可能会出现多个数据计算出的 hash 取模后的下标位置是同一个位置，即这个位置可能存在多个数据，那么当删除其中一个数据时，可能会导致另一个数据也会被误删。</p>\n<h2 id=\"优点-缺点\"><a class=\"markdownIt-Anchor\" href=\"#优点-缺点\">#</a> 优点、缺点</h2>\n<h3 id=\"优点\"><a class=\"markdownIt-Anchor\" href=\"#优点\">#</a> 优点</h3>\n<ul>\n<li>是由一串二进制数组组成，所以占用空间非常小</li>\n<li>插入和查询是很快的，因为他是计算数据的 hash 值，然后再由 hash 值映射到数组的下标，基于数组的特性，他的查询和插入时很快的，所以他的时间复杂度是 o (k)，k 表示 hash 函数的个数</li>\n<li>保密性好，存储的都是二进制数据，本身也不存储原始数据，无法得知 0、1 的意义是什么</li>\n</ul>\n<h3 id=\"缺点\"><a class=\"markdownIt-Anchor\" href=\"#缺点\">#</a> 缺点</h3>\n<ul>\n<li>很难实现删除操作</li>\n<li>存在误判这个数据本身不存在数组中，但是经过一系列计算后，判断这个数据存在于数组中，hash 冲突，解决办法是减小误判率，但是不能过小，因为减小误判率是通过增加 hash 函数实现的，当增加 hash 函数时，除了会增加计算时间外，因为会出现多个 hash 结果，他映射到数组中的位置也会增多，空间占用也会增加。为 1 不一定存在，但是为 0 一定不存在。</li>\n</ul>\n<h2 id=\"解决缓存穿透\"><a class=\"markdownIt-Anchor\" href=\"#解决缓存穿透\">#</a> 解决缓存穿透</h2>\n<p>当大量数据访问一个不存在于缓存中的数据，导致请求直接访问后端存储（如数据库），并且由于数据不存在，这个请求在缓存和后端存储中都没有命中，从而导致大量的请求流向后端存储，增加了系统的负载和响应时间。</p>\n<p>主要原因是恶意用户或者系统错误导致大量查询缓存中不存在的数据，这样的请求会绕过缓存，直接访问后端存储，导致后端存储的压力增大。</p>\n<p>为了应对缓存穿透问题，可以考虑以下方法：</p>\n<ol>\n<li><strong>缓存空值：</strong> 即使数据不存在，也在缓存中存储一个特殊值，表示这个数据不存在。这样，在下一次请求同样的数据时，就可以从缓存中快速判断数据不存在，而不会再次访问后端存储。</li>\n<li><strong>使用布隆过滤器：</strong> 布隆过滤器可以用来快速判断某个数据是否存在于缓存中。如果布隆过滤器判断数据不存在，就可以避免绕过缓存直接访问后端存储。</li>\n<li><strong>热点数据预加载：</strong> 针对系统中的热点数据，可以在系统启动时提前加载到缓存中，避免由于查询热点数据时导致缓存穿透。</li>\n<li><strong>限制请求频率：</strong> 可以在缓存层面限制同一个请求的频率，避免大量的恶意请求绕过缓存直接访问后端存储。</li>\n<li><strong>使用缓存云平台：</strong> 一些缓存云平台（如 AWS Elasticache、Redis Labs 等）提供了针对缓存穿透的解决方案，可以自动处理缓存穿透问题。</li>\n</ol>\n<h2 id=\"代码示例\"><a class=\"markdownIt-Anchor\" href=\"#代码示例\">#</a> 代码示例</h2>\n<p>这里的示例以我的用户是否浏览过记忆为例：</p>\n<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@RequiredArgsConstructor</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserViewedMemoryBloomFilterUtil</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">BLOOM_FILTER_KEY_PREFIX</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;memory_bloom_filter:&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">double</span> <span class=\"variable\">EXPECTED_INSERTIONS</span> <span class=\"operator\">=</span> <span class=\"number\">100000</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">double</span> <span class=\"variable\">FPP</span> <span class=\"operator\">=</span> <span class=\"number\">0.03</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 判断某个用户是否浏览过某个记忆</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> userId   用户ID</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> memoryId 记忆ID</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> true表示用户已经浏览过，false表示用户未浏览过</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">hasViewedMemory</span><span class=\"params\">(String userId, String memoryId)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">bloomFilterKey</span> <span class=\"operator\">=</span> BLOOM_FILTER_KEY_PREFIX + userId;</span><br><span class=\"line\">        <span class=\"type\">long</span>[] offsets = bloomFilterOffsets(memoryId);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">byte</span>[] bloomFilterBytes = (<span class=\"type\">byte</span>[]) redisTemplate.opsForValue().get(bloomFilterKey);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (bloomFilterBytes == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 布隆过滤器为空，则用户一定未浏览过该记忆</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 判断该记忆是否在布隆过滤器中</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">long</span> offset : offsets) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!getBit(bloomFilterBytes, offset)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 将某个记忆标记为已浏览过</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> userId   用户ID</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> memoryId 记忆ID</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">markMemoryAsViewed</span><span class=\"params\">(String userId, String memoryId)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">bloomFilterKey</span> <span class=\"operator\">=</span> BLOOM_FILTER_KEY_PREFIX + userId;</span><br><span class=\"line\">        <span class=\"type\">long</span>[] offsets = bloomFilterOffsets(memoryId);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">byte</span>[] bloomFilterBytes = (<span class=\"type\">byte</span>[]) redisTemplate.opsForValue().get(bloomFilterKey);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (bloomFilterBytes == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            bloomFilterBytes = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[getBloomFilterSize(EXPECTED_INSERTIONS, FPP)];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 将该记忆对应的位设置为1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">long</span> offset : offsets) &#123;</span><br><span class=\"line\">            setBit(bloomFilterBytes, offset);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        redisTemplate.opsForValue().set(bloomFilterKey, bloomFilterBytes);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取某个记忆在布隆过滤器中对应的位</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> memoryId 记忆ID</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 位的数组</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">long</span>[] bloomFilterOffsets(String memoryId) &#123;</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">hash1</span> <span class=\"operator\">=</span> MurmurHash.hash64(memoryId.getBytes(StandardCharsets.UTF_8), <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">hash2</span> <span class=\"operator\">=</span> MurmurHash.hash64(memoryId.getBytes(StandardCharsets.UTF_8), (<span class=\"type\">int</span>) hash1, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"type\">long</span>[] offsets = <span class=\"keyword\">new</span> <span class=\"title class_\">long</span>[<span class=\"number\">2</span>];</span><br><span class=\"line\">        offsets[<span class=\"number\">0</span>] = Math.abs(hash1 % getBloomFilterSize(EXPECTED_INSERTIONS, FPP));</span><br><span class=\"line\">        offsets[<span class=\"number\">1</span>] = Math.abs(hash2 % getBloomFilterSize(EXPECTED_INSERTIONS, FPP));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> offsets;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取布隆过滤器的大小</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> expectedInsertions 预期插入数量</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> fpp                期望的误判率</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 布隆过滤器的大小</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"title function_\">getBloomFilterSize</span><span class=\"params\">(<span class=\"type\">double</span> expectedInsertions, <span class=\"type\">double</span> fpp)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 根据预期插入数量和误判率计算布隆过滤器的大小</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">size</span> <span class=\"operator\">=</span> (<span class=\"type\">int</span>) Math.ceil((-expectedInsertions * Math.log(fpp)) / (Math.log(<span class=\"number\">2</span>) * Math.log(<span class=\"number\">2</span>)));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> size;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取指定位置的位的值</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> bytes  字节数组</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> offset 位的位置</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 位的值，true 表示 1，false 表示 0</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"title function_\">getBit</span><span class=\"params\">(<span class=\"type\">byte</span>[] bytes, <span class=\"type\">long</span> offset)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 因为一个 byte 等于 8 个 bit</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">index</span> <span class=\"operator\">=</span> (<span class=\"type\">int</span>) (offset / <span class=\"number\">8</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 得到在一个字节中的下标位置</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">bitPos</span> <span class=\"operator\">=</span> (<span class=\"type\">int</span>) (offset % <span class=\"number\">8</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 位运算，偏移 bitPos 下标位置的向量</span></span><br><span class=\"line\">        <span class=\"type\">byte</span> <span class=\"variable\">mask</span> <span class=\"operator\">=</span> (<span class=\"type\">byte</span>) (<span class=\"number\">1</span> &lt;&lt; bitPos);</span><br><span class=\"line\">        <span class=\"comment\">// 和数组中的对应位置的字节中的8位bit进行与运算，当该位置存在时即不等于0</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> (bytes[index] &amp; mask) != <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 将指定位置的位设置为 1</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> bytes  字节数组</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> offset 位的位置</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setBit</span><span class=\"params\">(<span class=\"type\">byte</span>[] bytes, <span class=\"type\">long</span> offset)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">index</span> <span class=\"operator\">=</span> (<span class=\"type\">int</span>) (offset / <span class=\"number\">8</span>);</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">bitPos</span> <span class=\"operator\">=</span> (<span class=\"type\">int</span>) (offset % <span class=\"number\">8</span>);</span><br><span class=\"line\">        <span class=\"type\">byte</span> <span class=\"variable\">mask</span> <span class=\"operator\">=</span> (<span class=\"type\">byte</span>) (<span class=\"number\">1</span> &lt;&lt; bitPos);</span><br><span class=\"line\">        <span class=\"comment\">// 或运算，只有该位置不存在时才将该位置设置成1</span></span><br><span class=\"line\">        bytes[index] |= mask;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></div>\n",
            "tags": [
                "面试题",
                "redis"
            ]
        },
        {
            "id": "https://wait-you.github.io/2023/08/06/HashSet%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/",
            "url": "https://wait-you.github.io/2023/08/06/HashSet%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/",
            "title": "HashSet工作原理",
            "date_published": "2023-08-06T00:26:51.000Z",
            "content_html": "<h1 id=\"hashset-工作原理\"><a class=\"markdownIt-Anchor\" href=\"#hashset-工作原理\">#</a> HashSet 工作原理</h1>\n<blockquote>\n<p>HashSet 是 Java 中的一种集合类，它使用哈希表（Hash Table）来存储元素。在哈希表中，元素的存储位置是根据它们的哈希码（Hash Code）来确定的</p>\n</blockquote>\n<ul>\n<li>\n<p>hashCode () 方法</p>\n<ul>\n<li>每个 Java 对象都有一个 hashCode () 方法，它返回一个 32 位的整数值，表示对象的哈希码。哈希码是根据对象的内容计算出来的，通常情况下，如果两个对象相等（通过 equals () 方法比较），那么它们的 hashCode () 方法应该返回相同的值，但反之则不一定成立（这种情况称为哈希冲突）。</li>\n</ul>\n</li>\n<li>\n<p>哈希表</p>\n<ul>\n<li>HashSet 内部使用了一个哈希表来存储元素。哈希表实际上是一个数组，数组的每个位置被称为 “桶”（Bucket）。当你往 HashSet 中添加元素时，HashSet 会首先计算该元素的 hashCode () 方法的返回值。</li>\n</ul>\n</li>\n<li>\n<p>计算索引</p>\n<ul>\n<li>计算出的 hashCode 值经过一定的处理（通常是取绝对值，然后对数组长度取余），得到一个在哈希表中的索引，这个索引就表示了元素在数组中的存放位置。这个索引对应的桶就是元素的存储位置。</li>\n</ul>\n</li>\n<li>\n<p>解决哈希冲突</p>\n<ul>\n<li>由于不同的对象可能会有相同的哈希码，所以在计算得到的索引位置可能已经有其他元素存在。这种情况称为哈希冲突。为了解决冲突，HashSet 使用了一些方法，最常见的是在同一个索引位置使用链表或者更高效的红黑树来存储多个元素，从而确保同一个索引位置可以存储多个元素。</li>\n</ul>\n</li>\n<li>\n<p>查找元素</p>\n<ul>\n<li>当你需要查找一个元素时，HashSet 会首先根据要查找元素的 hashCode 计算出索引，然后在对应的桶中查找元素。如果在链表或者红黑树中找到了对应的元素，就说明元素存在于集合中。</li>\n</ul>\n</li>\n</ul>\n<p><strong>HashSet 利用对象的 hashCode () 方法来计算哈希码，然后通过哈希码计算出在哈希表中的索引位置，最终将元素存储在对应的桶中。这种设计使得在集合中查找、插入和删除元素的操作可以在平均情况下达到常数时间复杂度，从而实现高效的元素存储和查找</strong></p>\n<blockquote>\n<p>当涉及到底层实现细节时，查看源代码是理解的一个很好的方法。下面我将用一些简化的 Java 源代码来说明 HashSet 是如何通过哈希码确定对象的位置的</p>\n</blockquote>\n<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HashSet</span>&lt;E&gt; <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractSet</span>&lt;E&gt; <span class=\"keyword\">implements</span> <span class=\"title class_\">Set</span>&lt;E&gt;, Cloneable, Serializable &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 哈希表，用于存储元素</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 虚拟的常量，用于作为哈希表中的value，因为HashSet的实现依赖于HashMap</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Object</span> <span class=\"variable\">PRESENT</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 构造方法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">HashSet</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加元素</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">add</span><span class=\"params\">(E e)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> map.put(e, PRESENT) == <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 内部实现类，用于存储元素的哈希表</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HashMap</span>&lt;K,V&gt; <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractMap</span>&lt;K,V&gt; <span class=\"keyword\">implements</span> <span class=\"title class_\">Map</span>&lt;K,V&gt;, Cloneable, Serializable &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 哈希桶数组，用于存储元素</span></span><br><span class=\"line\">        <span class=\"keyword\">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 计算哈希码</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"title function_\">hash</span><span class=\"params\">(Object key)</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">h</span> <span class=\"operator\">=</span> key.hashCode();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (key == <span class=\"literal\">null</span>) ? <span class=\"number\">0</span> : h ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 计算元素在哈希表中的索引</span></span><br><span class=\"line\">        <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">indexFor</span><span class=\"params\">(<span class=\"type\">int</span> h, <span class=\"type\">int</span> length)</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> h &amp; (length-<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 添加元素到哈希表</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> V <span class=\"title function_\">put</span><span class=\"params\">(K key, V value)</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">hash</span> <span class=\"operator\">=</span> hash(key);</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> indexFor(hash, table.length);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Node&lt;K,V&gt; e = table[i]; e != <span class=\"literal\">null</span>; e = e.next) &#123;</span><br><span class=\"line\">                Object k;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class=\"line\">                    <span class=\"type\">V</span> <span class=\"variable\">oldValue</span> <span class=\"operator\">=</span> e.value;</span><br><span class=\"line\">                    e.value = value;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            addEntry(hash, key, value, i);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 哈希表中的一个节点</span></span><br><span class=\"line\">        <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Node</span>&lt;K,V&gt; <span class=\"keyword\">implements</span> <span class=\"title class_\">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">int</span> hash;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> K key;</span><br><span class=\"line\">            V value;</span><br><span class=\"line\">            Node&lt;K,V&gt; next;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// ...</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></div>\n<p>上述代码只是一个简化版的示例，实际的 HashSet 和 HashMap 实现要更加复杂。关键点是：</p>\n<ul>\n<li>\n<p>HashSet 内部实际上使用了一个 HashMap 来存储元素，HashMap 中使用了哈希桶数组来存储节点。</p>\n</li>\n<li>\n<p>当调用 add () 方法将元素添加到 HashSet 时，实际上是通过 HashMap 的 put () 方法将元素添加到哈希表中。</p>\n</li>\n<li>\n<p>在 put () 方法中，首先会计算元素的哈希码，然后使用哈希码计算出在哈希桶数组中的索引位置。</p>\n</li>\n<li>\n<p>如果该索引位置已经存在其他节点（可能是哈希冲突），则会遍历链表或红黑树（根据节点数量）查找合适的位置来插入元素。</p>\n</li>\n</ul>\n<p><strong>总之，HashSet 利用了 HashMap 的哈希表实现，通过计算哈希码并选择合适的索引位置来确定对象在集合中的位置。这种机制保证了高效的元素查找和存储。要深入理解更多细节，最好还是查看 Java 源代码的实现。</strong></p>\n<p>源码中的 hash () 方法可能是一个疑点，他的作用及原理如下:<br>\n 假设我们有一个哈希码 h，二进制表示为： <code>11001010101110011011100110100101</code></p>\n<p>现在，我们进行无符号右移操作 h &gt;&gt;&gt; 16，将低 16 位移到高位，得到： <code>00000000000000001100101010111001</code></p>\n<p>接下来，我们进行异或操作 h ^ (h&gt;&gt;&gt; 16)，对应的位进行异或操作：</p>\n<div class=\"highlight-container\" data-rel=\"Markdown\"><figure class=\"iseeu highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">11001010101110011011100110100101</span><br><span class=\"line\"><span class=\"section\">00000000000000001100101010111001</span></span><br><span class=\"line\"><span class=\"section\">--------------------------------</span></span><br><span class=\"line\">11001010101110010111001100011100</span><br></pre></td></tr></table></figure></div>\n<p>通过异或操作，我们将原始哈希码的高位和低位进行了混合。现在，如果我们将得到的结果再转化为十进制，得到： <code>3361659324</code> 。</p>\n<p>这个结果相比于原始哈希码  <code>2864585453</code> ，已经发生了很大变化。这种混合的效果在位级别上实际上是将原始哈希码的不同部分交织在一起，增加了分布的随机性。这样的随机性有助于减少哈希冲突的发生，从而提高了哈希表的性能。</p>\n<p><strong>总之，位运算 h ^ (h&gt;&gt;&gt; 16) 的作用是将原始哈希码的高位和低位进行混合，生成一个在位级别上更随机的结果，从而提高哈希码的分布性</strong>。</p>\n<blockquote>\n<p>面试题</p>\n</blockquote>\n<p><strong>为什么重写 equals（）方法，就一定要重写 hashCode（）方法？</strong></p>\n<p>在 Java 中，当重写了 equals () 方法，目标是要在逻辑上判断两个对象是否相等，即它们的内容是否相同。然而，在涉及散列集合（如 HashSet、HashMap 等）时，不仅需要考虑逻辑上的相等，还需要确保哈希码相等的对象被放置在哈希表中同一个位置。这样才能正确地执行插入、查找、删除等操作。</p>\n<p>如果只重写了 equals () 方法，但没有重写 hashCode () 方法，就有可能出现以下问题：</p>\n<ul>\n<li>\n<p>不一致的哈希码： 两个对象在 equals () 方法中被判断为相等，但由于它们的 hashCode () 方法返回不同的哈希码，它们在散列集合中被当作不同的键插入。这会导致你无法正确查找或删除这些对象。</p>\n</li>\n<li>\n<p>无法正确覆盖： 在散列集合中，如果你希望用新的对象覆盖旧的对象（基于 equals () 判断相等），你需要确保新对象的哈希码与旧对象的哈希码相同。否则，你的新对象将被错误地放置在哈希表的另一个位置。</p>\n</li>\n</ul>\n<p>所以，为了保证逻辑相等的对象在散列集合中能够被正确地处理，必须同时重写 equals () 和 hashCode () 方法。这样，可以确保相等的对象拥有相同的哈希码，从而保证它们被正确处理并存储在散列集合中。</p>\n<p><strong>总之，重写 hashCode () 方法主要是为了保证逻辑相等的对象在散列集合中能够正确处理。如果仅在一般的逻辑判断中使用 equals () 方法，那么重写 hashCode () 并不是必需的。</strong></p>\n",
            "tags": [
                "面试题",
                "Hash"
            ]
        }
    ]
}
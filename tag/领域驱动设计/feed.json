{
    "version": "https://jsonfeed.org/version/1",
    "title": "玖忆 • All posts by \"领域驱动设计\" tag",
    "description": "我本微末凡尘、可也心向天空",
    "home_page_url": "https://wait-you.github.io",
    "items": [
        {
            "id": "https://wait-you.github.io/2023/06/06/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/",
            "url": "https://wait-you.github.io/2023/06/06/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/",
            "title": "领域驱动设计",
            "date_published": "2023-06-06T01:10:51.000Z",
            "content_html": "<h1 id=\"领域驱动设计\"><a class=\"markdownIt-Anchor\" href=\"#领域驱动设计\">#</a> 领域驱动设计</h1>\n<h2 id=\"大型系统是如何变老的\"><a class=\"markdownIt-Anchor\" href=\"#大型系统是如何变老的\">#</a> 大型系统是如何 &quot;变老&quot; 的</h2>\n<h3 id=\"面临的问题\"><a class=\"markdownIt-Anchor\" href=\"#面临的问题\">#</a> 面临的问题</h3>\n<p>当一个项目使用过长，他的运行效率低、代码乱，需要重构的时候，需要面临一些问题</p>\n<ul>\n<li>沟通难\n<ul>\n<li>产品提出一个问题，开发却要很久</li>\n</ul>\n</li>\n<li>开发难\n<ul>\n<li>代码膨胀，对于大型软件，一个旧的类可能有上千行，无法确定更改后的影响有多大</li>\n</ul>\n</li>\n<li>测试难\n<ul>\n<li>改了个需求，测试需要组织庞大的测试计划</li>\n</ul>\n</li>\n<li>创新难\n<ul>\n<li>系统背负的业务越来越重，已经基本丧失了对新技术的灵活敏感</li>\n<li>比如从 <code>orm</code>  从 <code>hebernate</code>  换到 <code>mybatis</code> ，因为业务代码是耦合的，无法轻易的更换</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"微服务架构更在防止系统老化吗\"><a class=\"markdownIt-Anchor\" href=\"#微服务架构更在防止系统老化吗\">#</a> 微服务架构更在防止系统 &quot; 老化’' 吗</h3>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"http://tuchuang.wenhe9.cn/img/202211051602718.png\"\n                      alt=\"image-20221105160246592\"\n                ></p>\n<p>虽然在一开始将一个电商项目根据功能分成了若干个微服务，但是随着系统体量的不断增大，某一个或某几个微服务的功能可能也会变得无比庞大，导致系统 &quot;老化&quot;。所以微服务对于防止系统老化只是一个治标不治本的方式。</p>\n<h3 id=\"ddd被认为是目前最理想的方式\"><a class=\"markdownIt-Anchor\" href=\"#ddd被认为是目前最理想的方式\">#</a> DDD 被认为是目前最理想的方式</h3>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"http://tuchuang.wenhe9.cn/img/202211051614128.png\"\n                      alt=\"image-20221105161428086\"\n                ></p>\n<p>在业务上分成一个个的 <code>domain</code>  领域，每个领域只针对自己业务上的属性，系统上不在以 <code>mvc</code>  构建，而是以带有自己功能的领域来构成。这样在微服务进行拆分时，最理想的方式是可以随意按照领域拆分，这样子的话，项目就可以自由组合，结合微服务的体系，更好的体现微服务的能力，使得系统茁壮的成长。</p>\n<h3 id=\"ddd的保证措施\"><a class=\"markdownIt-Anchor\" href=\"#ddd的保证措施\">#</a> DDD 的保证措施</h3>\n<p><code>DDD</code>  使得一些工作经验不多的人可以对相关功能进行负责，但是需要一些保证措施。</p>\n<p><code>mvc</code>  架构的隐患</p>\n<ul>\n<li>数据库\n<ul>\n<li>用户的模块发生变化，比如新增了一个字段等等，那么在代码层面可能都需要做一个修改</li>\n</ul>\n</li>\n<li>其他的微服务调用或者第三方 api\n<ul>\n<li>调用方式发生改变</li>\n<li>其他微服务或第三方 api 业务发生变化，比如校验码发生变化，那么在业务代码对获取到的校验码的判断也需要做出相应的修改</li>\n</ul>\n</li>\n<li>消息队列\n<ul>\n<li>当中间介更换的时候，调用的方式也需要进行变化</li>\n</ul>\n</li>\n</ul>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"http://tuchuang.wenhe9.cn/img/202211051626670.png\"\n                      alt=\"\"\n                ></p>\n<p><code>mvc</code>  到 <code>ddd</code>  的改造</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"http://tuchuang.wenhe9.cn/img/202211052014483.png\"\n                      alt=\"image-20221105201437426\"\n                ></p>\n<p><strong>将周边的所有的变化隔离开，留下自己的核心</strong></p>\n<ul>\n<li>\n<p>数据库</p>\n<ul>\n<li>对于数据库的操作不再是引入操作数据库的 <code>dao</code> ，而是通过一个 <code>Repository</code>  接口，这样子当数据源发生变化时，通过这样的一个接口隔离，这样子 <code>orm</code>  的具体实现不会影响到业务，切换的时候只需要更换 <code>Repostory</code>  的具体的实现类，整体的业务不需要变化</li>\n<li>使得业务只需要拿到数据即可，至于数据是从哪里来的，这个不用管</li>\n</ul>\n</li>\n<li>\n<p>实体</p>\n<ul>\n<li>\n<p>以往的实体 <code>pojo</code>  只需要有一些属性，一些 <code>setter</code> 、 <code>getter</code> ，在 <code>ddd</code>  中把实体和他的业务方法封装到一起，构成一个充血模型，以前的 <code>pojo</code>  是一个贫血模型</p>\n</li>\n<li>\n<p>以前的 <code>pojo</code>  实体会把所有属性放在一个大的实体类里，然后通过上层的 <code>service</code>  来对这些属性做不同的操作，实现不同的业务，这样会造成<strong>贫血失忆症</strong>的后果，即从这个实体上看不出他是要做什么事情的</p>\n</li>\n<li>\n<p>所以在充血模型，把业务方法上进来的好处就是，这个实体要做什么事情就会一目了然的</p>\n</li>\n</ul>\n</li>\n<li>\n<p>值对象</p>\n<ul>\n<li>访问值对象必须通过实体来访问</li>\n<li>但也不是所有场景都必须通过实体类获取值对象，根据是否是业务来判断</li>\n</ul>\n</li>\n<li>\n<p>业务</p>\n<ul>\n<li><code>DDD</code>  业务指造成实体状态变化的过程，即使得实体的属性发生变化的方法</li>\n</ul>\n</li>\n<li>\n<p>防腐层</p>\n<ul>\n<li>隔离外部服务\n<ul>\n<li>封装一个 <code>SafeService</code>  接口，将其他微服务或第三方 api 的调用放到这个接口里，在这个接口里进行调用和返回结果的判断</li>\n</ul>\n</li>\n<li>隔离第三方组件\n<ul>\n<li>封装 <code>MessageProducer</code>  和 <code>MessageConsumer</code>  接口，在这个接口里指定对应的组件，并实现对应使用该组件的方法</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>领域服务 隔离实体</p>\n<ul>\n<li>将修改实体状态而业务代码，也封装成一个接口，在接口的方法中调用实体的业务方法，这样子的好处是，以后再新增一些新的业务的时候，也不会说使得业务层类的代码过于庞大，并且因为使用接口组合的方式，业务的可扩展性也更好，耦合度更低</li>\n</ul>\n</li>\n</ul>\n<p>重新编排后的好处</p>\n<ul>\n<li>业务逻辑清晰，数据流转与业务逻辑完全分离</li>\n<li>各个模块的功能都是相对独立的，没有外部依赖，可以单独测试</li>\n<li>原有的 <code>service</code>  不再包含任何具体业务的逻辑，仅仅作为组件编排</li>\n</ul>\n<h3 id=\"ddd四层架构\"><a class=\"markdownIt-Anchor\" href=\"#ddd四层架构\">#</a> DDD 四层架构</h3>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"http://tuchuang.wenhe9.cn/img/202211052021437.png\"\n                      alt=\"image-20221105202154385\"\n                ></p>\n",
            "tags": [
                "领域驱动设计"
            ]
        }
    ]
}